#!/usr/bin/env bash
# ==============================================================================
# restore-rpool-data.safe.sh — Safety-first ZFS restore for Proxmox (FULL + ALL INCR)
#
# Goal:
#   Restore *everything except the Proxmox OS* from a ZFS FULL + INCR chain,
#   safely, with confirmations at every important step.
#
# Strategy:
#   1) Offer to export foreign pools (avoid conflicts)
#   2) Receive FULL into rpool/RESTORE
#   3) Auto-detect ALL incrementals in the current dir (*.incr.zst), sort, preflight,
#      then apply in order into rpool/RESTORE
#   4) Replicate top-level datasets (excluding rpool/RESTORE/ROOT/*) back to rpool/*
#      with -R -I to preserve snapshots/history
#
# Will change:
#   - Non-ROOT datasets under rpool (e.g., rpool/data, rpool/subvol-*, etc.)
#   - Targets are received with -F (rollback/overwrite) — *after your confirmation*
#
# Will NOT change:
#   - rpool/ROOT/* (fresh Proxmox OS, kernels, initramfs, GRUB) — never touched
#
# Inputs (env / prompts):
#   - FULL_ZST   : path to full ZFS backup (.zst). Prompted if missing. Default: ./rpool.full.zst
#   - INCR_GLOB  : shell glob to find incrementals (default: ./*.incr.zst)
#
# Requirements:
#   - Run as root on the freshly installed Proxmox host
#   - zfs, zpool, zstd installed (pv optional), zstreamdump (from zfs-dbg or zfsutils has it)
# ==============================================================================
set -Eeuo pipefail

# ------------------------------ Config -----------------------------------------
POOL_NAME="rpool"                 # Destination pool (fresh OS installed here)
RESTORE_NS="${POOL_NAME}/RESTORE" # Temporary receive namespace (inside rpool)
PV_BIN="${PV_BIN:-pv}"            # Optional progress (apt install pv)
COLOR=1                           # Set 0 to disable ANSI colors

# ------------------------------ UI Helpers -------------------------------------
cblue()   { [[ $COLOR -eq 1 ]] && printf "\033[1;34m%s\033[0m" "$*" || printf "%s" "$*"; }
cyellow() { [[ $COLOR -eq 1 ]] && printf "\033[1;33m%s\033[0m" "$*" || printf "%s" "$*"; }
cred()    { [[ $COLOR -eq 1 ]] && printf "\033[1;31m%s\033[0m" "$*" || printf "%s" "$*"; }

log()  { printf "%s %s\n" "$(cblue "[INFO]")"   "$*"; }
warn() { printf "%s %s\n" "$(cyellow "[WARN]")" "$*"; }
err()  { printf "%s %s\n" "$(cred "[ERR ]")"    "$*" >&2; }
die()  { err "$*"; exit 1; }

need_bin() { command -v "$1" >/dev/null 2>&1 || die "Missing required binary: $1"; }

confirm() {
  local prompt="${1:-Proceed? [y/N]}"; local reply
  read -r -p "$prompt " reply || true
  [[ "${reply,,}" == "y" || "${reply,,}" == "yes" ]]
}

pause_enter() { read -r -p "Press ENTER to continue..." _ || true; }

trap 'err "Aborted (exit code $?)."; exit 1' ERR

# ------------------------------ Preconditions ----------------------------------
[[ "${EUID:-$(id -u)}" -eq 0 ]] || die "Please run as root."

need_bin zfs
need_bin zpool
need_bin zstd
if ! command -v zstreamdump >/dev/null 2>&1; then
  warn "zstreamdump not found — preflight checks will be limited. (On Debian/Proxmox, it's in zfs-utils)"
fi
if ! command -v "$PV_BIN" >/dev/null 2>&1; then
  warn "pv not found — progress bars limited. You can: apt install pv"
  PV_BIN=""
fi

# Ensure destination pool exists and is imported
zpool list -H -o name | grep -qx "$POOL_NAME" \
  || die "ZFS pool '$POOL_NAME' is not imported. Install/import your fresh Proxmox ZFS root first."
# Ensure OS dataset exists (we never touch this)
zfs list -H -o name "${POOL_NAME}/ROOT" >/dev/null 2>&1 \
  || die "Expected dataset '${POOL_NAME}/ROOT' missing. Are you on a fresh ZFS-root install?"

# ------------------------------ Optional Pool Export ---------------------------
log "Checking for other imported pools (besides '${POOL_NAME}')..."
OTHER_POOLS="$(zpool list -H -o name | grep -vx "$POOL_NAME" || true)"
if [[ -n "$OTHER_POOLS" ]]; then
  warn "Other imported pools detected:"
  printf "  - %s\n" $OTHER_POOLS
  if confirm "Export these pools now so they can be safely re-imported later? [y/N]"; then
    for p in $OTHER_POOLS; do
      log "Exporting pool: $p"
      zpool export "$p"
    done
    log "Export complete. Re-import later with: zpool import <poolname>"
  else
    warn "Leaving other pools imported. If you hit GUID/name conflicts, export them and retry."
  fi
else
  log "No other imported pools detected."
fi

# ------------------------------ Inputs -----------------------------------------
FULL_ZST="${FULL_ZST:-}"
INCR_GLOB="${INCR_GLOB:-./*.incr.zst}"

ask_file() {
  local var="$1" default="$2" label="$3" val
  val="${!var:-}"
  if [[ -z "$val" ]]; then
    local prompt="Path to ${label}"
    [[ -n "$default" ]] && prompt+=" [${default}]"
    prompt+=": "
    read -r -p "$prompt" val || true
    val="${val:-$default}"
    printf -v "$var" "%s" "$val"
  fi
}

default_full="./rpool.full.zst"
log "Collecting backup inputs…"
ask_file FULL_ZST "$default_full" "FULL backup (.zst), e.g. rpool.full.zst"
[[ -f "$FULL_ZST" ]] || die "FULL backup not found: $FULL_ZST"

# Find incrementals by glob (if none, that's fine; we can restore FULL only)
readarray -t INCR_FILES < <(ls -1 $INCR_GLOB 2>/dev/null | sort -V || true)
if [[ ${#INCR_FILES[@]} -eq 0 ]]; then
  warn "No incrementals matched glob: $INCR_GLOB"
  if ! confirm "Continue with FULL only? [y/N]"; then
    die "User aborted (no incrementals)."
  fi
else
  log "Detected incrementals (in order):"
  printf "  - %s\n" "${INCR_FILES[@]}"
  if ! confirm "Apply ALL of the above incrementals in order after FULL? [y/N]"; then
    die "User aborted incremental application."
  fi
fi

log "FULL : $FULL_ZST"
[[ ${#INCR_FILES[@]} -gt 0 ]] && log "INCR : ${#INCR_FILES[@]} file(s) via '${INCR_GLOB}'"
log "Pool : $POOL_NAME"

if ! confirm "⚠️ This will receive into '${POOL_NAME}/RESTORE' then replicate back to '${POOL_NAME}/*' (excluding ROOT). Continue? [y/N]"; then
  die "User aborted."
fi

# ------------------------------ Namespace Prep ---------------------------------
ensure_namespace() {
  if zfs list -H -o name "$RESTORE_NS" >/dev/null 2>&1; then
    warn "Namespace exists: '$RESTORE_NS'"
    if confirm "DELETE existing namespace to do a clean receive? [y/N]"; then
      warn "About to DESTROY '$RESTORE_NS' recursively!"
      if confirm "FINAL CONFIRM — destroy '${RESTORE_NS}' and all descendants? [y/N]"; then
        zfs destroy -r "$RESTORE_NS"
        log "Destroyed old namespace."
      else
        die "User cancelled namespace destruction."
      fi
    else
      warn "Re-using existing namespace as-is."
    fi
  fi

  if ! zfs list -H -o name "$RESTORE_NS" >/dev/null 2>&1; then
    log "Creating namespace: $RESTORE_NS"
    zfs create -p "$RESTORE_NS"
  fi
}

# ------------------------------ Stream Receive ---------------------------------
receive_stream_into() {
  local zst="$1" label="$2"
  [[ -f "$zst" ]] || die "Missing stream: $zst"
  log "Ready to receive ${label} into '${RESTORE_NS}'."
  if ! confirm "Proceed receiving ${label}? This may overwrite existing datasets under '${RESTORE_NS}'. [y/N]"; then
    die "User aborted ${label} receive."
  fi

  if [[ -n "$PV_BIN" ]]; then
    local size; size="$(du -b -- "$zst" 2>/dev/null | awk '{print $1}')" || size=""
    if [[ -n "$size" ]]; then
      zstd -dc -- "$zst" | "$PV_BIN" -s "$size" | zfs recv -F "$RESTORE_NS"
    else
      zstd -dc -- "$zst" | "$PV_BIN" | zfs recv -F "$RESTORE_NS"
    fi
  else
    zstd -dc -- "$zst" | zfs recv -F "$RESTORE_NS"
  fi
  log "${label} receive complete."
}

# Extract the required fromsnap name from an incremental (best-effort)
incr_required_fromsnap() {
  local zst="$1"
  if command -v zstreamdump >/dev/null 2>&1; then
    zstd -dc -- "$zst" | zstreamdump -v \
      | awk '/fromsnap = /{print $3; exit}'
  else
    # No zstreamdump — cannot preflight; return empty
    echo ""
  fi
}

# Verify that a snapshot with @fromsnap exists somewhere under RESTORE_NS
preflight_incr_has_base() {
  local zst="$1" fromsnap="$2"
  [[ -z "$fromsnap" ]] && return 0  # cannot check; let recv handle
  if zfs list -t snapshot -r "$RESTORE_NS" -H -o name | grep -q "@${fromsnap}\$"; then
    return 0
  else
    return 1
  fi
}

# ------------------------------ Dataset Listing --------------------------------
list_children_excluding_root() {
  zfs list -H -o name "$RESTORE_NS"/* 2>/dev/null | grep -vE "^${RESTORE_NS}/ROOT($|/)" || true
}

dataset_snaps_oldest_newest() {
  local ds="$1"
  local snaps
  snaps="$(zfs list -H -t snapshot -o name -S creation -r "$ds" | awk -F@ -v p="$ds" '$1==p{print $0}')" || true
  [[ -n "$snaps" ]] || return 1
  local newest oldest
  newest="$(echo "$snaps" | head -n1)"
  oldest="$(echo "$snaps" | tail -n1)"
  printf "%s %s\n" "$oldest" "$newest"
}

replicate_one_dataset() {
  local src="$1" rel="${src#${RESTORE_NS}/}" dst="${POOL_NAME}/${rel}"

  log "Planning: $src  →  $dst"

  if zfs list -H -o name "$dst" >/dev/null 2>&1; then
    warn "Target exists: $dst"
    if ! confirm "Allow overwrite/rollback of '$dst' via 'zfs recv -F'? [y/N]"; then
      warn "Skipping $dst by user choice."
      return 0
    fi
  fi

  local parent; parent="$(dirname "$dst")"
  if ! zfs list -H -o name "$parent" >/dev/null 2>&1; then
    log "Creating parent dataset: $parent"
    zfs create -p "$parent"
  fi

  local range; range="$(dataset_snaps_oldest_newest "$src" || true)"
  if [[ -z "$range" ]]; then
    warn "No snapshots on $src. Creating temporary snapshot of current state."
    local ts; ts="$(date +%Y%m%d-%H%M%S)"
    zfs snapshot "$src@_restore_tmp_${ts}"
    range="$(dataset_snaps_oldest_newest "$src")" || die "Failed to snapshot $src"
  fi
  local oldest newest
  oldest="$(awk '{print $1}' <<<"$range")"
  newest="$(awk '{print $2}' <<<"$range")"

  log "Will replicate with history:"
  log "  Oldest: $oldest"
  log "  Newest: $newest"

  if ! confirm "Proceed with replication of '$src' to '$dst'? [y/N]"; then
    warn "Skipped by user."
    return 0
  fi

  if [[ -n "$PV_BIN" ]]; then
    zfs send -R -I "$oldest" "$newest" | "$PV_BIN" | zfs recv -F "$dst"
  else
    zfs send -R -I "$oldest" "$newest" | zfs recv -F "$dst"
  fi

  log "Replication complete: $dst"
}

# ------------------------------ Execution --------------------------------------
log "Step 1/7 — Prepare restore namespace"
ensure_namespace
pause_enter

log "Step 2/7 — Receive FULL stream"
receive_stream_into "$FULL_ZST" "FULL"
pause_enter

log "Step 3/7 — Apply ALL incrementals (if any)"
if [[ ${#INCR_FILES[@]} -gt 0 ]]; then
  for incr in "${INCR_FILES[@]}"; do
    [[ -f "$incr" ]] || die "Incremental missing: $incr"
    local_from="$(incr_required_fromsnap "$incr" || true)"
    if [[ -n "$local_from" ]]; then
      log "Preflight: '$incr' requires base snapshot '@${local_from}' under '${RESTORE_NS}'."
      if preflight_incr_has_base "$incr" "$local_from"; then
        log "  ✓ Base snapshot '@${local_from}' found under RESTORE."
      else
        err "  ✗ Base snapshot '@${local_from}' NOT found under RESTORE. Cannot apply '$incr'."
        err "    → Ensure you've applied all earlier incrementals, or that your FULL contains this base snapshot."
        exit 1
      fi
    else
      warn "Skipping preflight for '$incr' (zstreamdump not available or fromsnap not detectable)."
    fi
    receive_stream_into "$incr" "INCREMENTAL ($(basename "$incr"))"
  done
else
  warn "No incrementals detected — proceeding with FULL only."
fi
pause_enter

log "Step 4/7 — Enumerate candidate datasets under ${RESTORE_NS} (excluding ROOT)"
children="$(list_children_excluding_root)"
[[ -n "$children" ]] || die "No datasets found under ${RESTORE_NS}. Check streams."

printf "%s\n" "These top-level datasets are candidates for replication:"
printf "  - %s\n" $children
echo

ONLY_VM_LXC=0
if confirm "Replicate ONLY VM/LXC data ('${RESTORE_NS}/data' and '${RESTORE_NS}/subvol-*')? [y/N]"; then
  ONLY_VM_LXC=1
fi

if [[ $ONLY_VM_LXC -eq 1 ]]; then
  filtered=""
  for ds in $children; do
    if [[ "$ds" == "${RESTORE_NS}/data" || "$ds" == ${RESTORE_NS}/subvol-* ]]; then
      filtered+="$ds"$'\n'
    fi
  done
  children="$(echo "$filtered" | sed '/^$/d' || true)"
  [[ -n "$children" ]] || die "No VM/LXC datasets matched. Aborting."
  warn "Filtered list:"
  printf "  - %s\n" $children
fi

if ! confirm "Proceed to replicate the above list into '${POOL_NAME}'? [y/N]"; then
  die "User aborted before replication."
fi

PER_DATASET_CONFIRM=0
if confirm "Ask for confirmation PER dataset? [y/N]"; then
  PER_DATASET_CONFIRM=1
fi

log "Step 5/7 — Replication"
for ds in $children; do
  [[ "$ds" == "${RESTORE_NS}/ROOT" || "$ds" == "${RESTORE_NS}/ROOT/"* ]] && continue
  if [[ $PER_DATASET_CONFIRM -eq 1 ]]; then
    if ! confirm "Replicate '$ds'? [y/N]"; then
      warn "Skipping '$ds' per user choice."
      continue
    fi
  fi
  replicate_one_dataset "$ds"
  echo
done
pause_enter

log "Step 6/7 — Post-restore options"
if confirm "Delete the temporary namespace '${RESTORE_NS}' now? [y/N]"; then
  warn "This will destroy '${RESTORE_NS}' recursively."
  if confirm "FINAL CONFIRM — Destroy '${RESTORE_NS}'? [y/N]"; then
    zfs destroy -r "$RESTORE_NS"
    log "Removed restore namespace."
  else
    warn "Kept restore namespace."
  fi
else
  warn "Keeping restore namespace for inspection."
fi

log "Step 7/7 — Wrap-up"
log "✅ Done. Your fresh '${POOL_NAME}/ROOT' was preserved."
echo "Next steps:"
echo "  • Proxmox UI → Datacenter → Storage: ensure ZFS storage points at '${POOL_NAME}'."
echo "  • Restore or recreate VM configs in /etc/pve/qemu-server/*.conf (e.g.: scsi0: local-zfs:vm-101-disk-0,size=XXG)."
echo "  • Start VMs: qm start <VMID>"
