#!/usr/bin/env bash
# git-sync — GitOps-style config backup for Proxmox VE / Coolify (Shell Expert rewrite)
# ==============================================================================
# Welcome!
# This single-file utility periodically snapshots important configuration files
# into a Git repository (via SSH) using a GitOps-style workflow. It’s designed
# for Proxmox VE and Coolify hosts, supports offline commits (push later), and
# integrates healthchecks, journald/file logging, self-update, and a recovery
# shell — all powered by the Shell Expert library.
#
# Highlights
#   • INFO/WARN/ERROR logs with step banners (library-driven)
#   • During "install": first test SSH access; only if it fails do gh auth/key
#   • During "run": NEVER do gh routines; rely on existing access
#   • Trust GitHub SSH host key (ssh-keyscan)
#   • Installs nodejs/npm; installs aicommits if missing
#   • Prompts once for OPENAI_KEY (TTY only); token never logged
#   • AI commits non-interactively: `echo | aicommits --force` or `aic --force`
#   • systemd timer; logs → journald and /var/log/git-sync.log
#   • Healthchecks: GET /start → POST trimmed **/var/log/git-sync.log**
#   • Concurrency-safe (flock); offline-tolerant (local commits → later push)
#   • Size filters:
#       - Skip files > MAX_FILE_SIZE (default 10m) everywhere.
#       - Under /data/coolify, exclude directories > MAX_DIR_SIZE_BYTES (10 MiB)
#         up to MAX_DIR_DEPTH (default 5) and delete them from the snapshot.
#
# Environment Variables (export or set inline)
# ┌────────────────────────────────┬─────────────────────────────────────────────┐
# │ Variable                       │ Description                                 │
# ├────────────────────────────────┼─────────────────────────────────────────────┤
# │ PVE_GIT_REPO                   │ Git SSH URL of the config repo.             │
# │                                │ Default (Coolify):                          │
# │                                │   git@github.com:ProfessorManhattan/        │
# │                                │   coolify-configs.git                       │
# │                                │ Default (Proxmox):                          │
# │                                │   git@github.com:ProfessorManhattan/        │
# │                                │   proxmox-configs.git                       │
# ├────────────────────────────────┼─────────────────────────────────────────────┤
# │ WORK_TREE                      │ Local checkout directory.                   │
# │                                │ Default: /usr/local/share/git-sync          │
# ├────────────────────────────────┼─────────────────────────────────────────────┤
# │ HEALTHCHECKS_URL               │ Healthchecks base URL or full ping URL.     │
# │                                │ If only base given, a key/slug URL is       │
# │                                │ auto-created by the library.                │
# ├────────────────────────────────┼─────────────────────────────────────────────┤
# │ HEALTHCHECK_LOG_BYTES          │ Max bytes to upload to healthchecks.        │
# │                                │ If unset, auto-detect Ping-Body-Limit;      │
# │                                │ fallback 1,000,000.                         │
# ├────────────────────────────────┼─────────────────────────────────────────────┤
# │ GIT_SIGNING_KEY                │ Optional GPG key ID; if set, commits signed.│
# ├────────────────────────────────┼─────────────────────────────────────────────┤
# │ SYNC_INTERVAL                  │ systemd timer interval (5m, 15m, 1h...).    │
# │                                │ Default: 15m                                │
# ├────────────────────────────────┼─────────────────────────────────────────────┤
# │ PVE_GIT_DEBUG                  │ If "1", prints DEBUG logs (no secrets).     │
# ├────────────────────────────────┼─────────────────────────────────────────────┤
# │ SYNC_PATHS                     │ Optional Bash array overriding defaults.    │
# │                                │ Example: SYNC_PATHS=(/etc/pve /etc/network) │
# ├────────────────────────────────┼─────────────────────────────────────────────┤
# │ MAX_FILE_SIZE                  │ Max size for individual files copied into   │
# │                                │ snapshot (rsync --max-size). Default: 10m.  │
# ├────────────────────────────────┼─────────────────────────────────────────────┤
# │ SIZE_FILTER_BASE               │ Base path to scan for oversize directories  │
# │                                │ (Coolify only). Default: /data/coolify.     │
# ├────────────────────────────────┼─────────────────────────────────────────────┤
# │ MAX_DIR_DEPTH                  │ Consider directories only up to this depth  │
# │                                │ under SIZE_FILTER_BASE. Default: 5.         │
# ├────────────────────────────────┼─────────────────────────────────────────────┤
# │ MAX_DIR_SIZE_BYTES             │ Directories larger than this (total size)   │
# │                                │ are excluded from snapshot when under base. │
# │                                │ Default: 10485760 (10 MiB).                 │
# └────────────────────────────────┴─────────────────────────────────────────────┘
#
# Usage
#   git-sync install       # install service+timer (prompts OPENAI_KEY)
#   git-sync run           # one-off sync now (default; no gh auth)
#   git-sync status        # view systemd/logs
#   git-sync uninstall     # remove service+timer
#   git-sync self-update   # force self-update now
#   git-sync recover       # recovery shell (auto-exits after inactivity)
#   git-sync help          # compact usage, env defaults, examples
#
# Examples
#   PVE_GIT_REPO=git@github.com:me/proxmox-configs.git git-sync install
#   SYNC_INTERVAL=5m git-sync install
#   SYNC_PATHS=(/etc/pve /etc/network) git-sync run
#
# Key Paths
#   • Service:  /etc/systemd/system/git-sync.service
#   • Timer:    /etc/systemd/system/git-sync.timer
#   • WorkTree: /usr/local/share/git-sync (default)
#   • Config:   /etc/git-sync.conf (compat), plus XDG JSON metadata
#   • Logs:     /var/log/git-sync.log (file) + journald (library)
#
# ============================================================================

# --- Bootstrap: Shell Expert library (do not modify) -------------------------
U="${SE_LIB_URL:-https://public.megabyte.space/source.sh}"
P="${SE_LIB_PATH:-}"
if [[ -n "$P" && -r "$P" ]]; then . "$P"; else
  C=(/usr/local/lib/shell-expert/source.sh ./source.sh "${XDG_CACHE_HOME:-$HOME/.cache}/shell-expert/source.sh")
  for p in "${C[@]}"; do [[ -r "$p" ]] && { . "$p"; P="$p"; break; }; done
  if [[ -z "$P" ]]; then
    D="${XDG_CACHE_HOME:-$HOME/.cache}/shell-expert"; mkdir -p "$D" || { D="/tmp/se-${USER:-$(id -u)}"; mkdir -p "$D" || { printf 'ERR: cache\n' >&2; exit 74; }; }
    T="$(mktemp "$D/.dl.XXXX")" || { printf 'ERR: mktemp\n' >&2; exit 70; }
    if command -v curl >/dev/null; then curl -fsS --connect-timeout 5 -m 20 --retry 3 --retry-all-errors -o "$T" "$U" || { printf 'ERR: fetch\n' >&2; exit 69; }
    elif command -v wget >/dev/null; then wget -q -O "$T" "$U" || { printf 'ERR: fetch\n' >&2; exit 69; }
    else printf 'ERR: need curl/wget\n' >&2; exit 69; fi
    bash -n "$T" || { printf 'ERR: syntax\n' >&2; exit 70; }
    P="$D/source.sh"; mv -f "$T" "$P"; chmod 0644 "$P" || true
    [[ -d /usr/local/lib && -w /usr/local/lib ]] && { mkdir -p /usr/local/lib/shell-expert 2>/dev/null || true; cp -f "$P" /usr/local/lib/shell-expert/source.sh 2>/dev/null || true; }
    . "$P"
  fi
fi
VERSION="${VERSION:-$(TZ=America/New_York date +'%Y%m%d-%H%M%S')}"

# Immediately after sourcing:
UPDATE_URL="https://raw.githubusercontent.com/HeyMegabyte/install.doctor/refs/heads/master/home/dot_config/system/usr/local/bin/executable_git-sync"   # TODO: set to your canonical raw script URL
SLUG="$(se_slug_from_url "$UPDATE_URL")"
se_init_context "$SLUG" "$UPDATE_URL"; se_set_update_url "$SLUG" "$UPDATE_URL"
se_self_update "$SLUG" "$UPDATE_URL" "/usr/local/bin/$SLUG"

set -Eeuo pipefail

# --- Constants & defaults ----------------------------------------------------
LOG_FILE="/var/log/git-sync.log"
CONF_FILE="/etc/git-sync.conf"           # legacy compat; JSON also stored via XDG
WORK_TREE_DEFAULT="/usr/local/share/git-sync"
SERVICE_NAME="git-sync.service"
TIMER_NAME="git-sync.timer"
SERVICE_PATH="/etc/systemd/system/${SERVICE_NAME}"
TIMER_PATH="/etc/systemd/system/${TIMER_NAME}"
LOCKFILE="/run/git-sync.lock"

DEFAULT_TIMER_INTERVAL="15m"

# Detect environment to set defaults for repo + healthchecks
if [[ -d /data/coolify ]]; then
  DEFAULT_HEALTHCHECK_URL="https://healthchecks.megabyte.space/ping/csjKSM11DRvU5ZjHMmYxYg/coolify-git-config"
  DEFAULT_REPO="git@github.com:ProfessorManhattan/coolify-configs.git"
  DEFAULT_SYNC_PATHS=(
    "/etc/coolify" "/opt/coolify" "/var/lib/coolify" "/var/log/coolify"
    "/root/.ssh" "/root/.coolify.env" "/data/coolify"
  )
else
  # Assume Proxmox when /etc/pve exists
  if [[ -d /etc/pve ]]; then
    DEFAULT_HEALTHCHECK_URL="https://healthchecks.megabyte.space/ping/csjKSM11DRvU5ZjHMmYxYg/proxmox-git-config"
    DEFAULT_REPO="git@github.com:ProfessorManhattan/proxmox-configs.git"
    DEFAULT_SYNC_PATHS=(
      "/etc/pve" "/etc/network" "/etc/ssh/config" "/root/.ssh" "/etc/apt"
      "/etc/fstab" "/etc/hosts" "/etc/resolv.conf" "/etc/hostname"
      "/etc/pve/firewall" "/etc/corosync" "/etc/ceph" "/etc/chrony"
      "/etc/systemd/timesyncd.conf"
    )
  else
    # Generic defaults if neither path exists at authoring time
    DEFAULT_HEALTHCHECK_URL=""
    DEFAULT_REPO=""
    DEFAULT_SYNC_PATHS=(/etc)
  fi
fi

# Size filter defaults
MAX_FILE_SIZE="${MAX_FILE_SIZE:-10m}"
SIZE_FILTER_BASE="${SIZE_FILTER_BASE:-/data/coolify}"
MAX_DIR_DEPTH="${MAX_DIR_DEPTH:-5}"
MAX_DIR_SIZE_BYTES="${MAX_DIR_SIZE_BYTES:-10485760}" # 10 MiB
SIZE_EXCLUDE_FILE=""

# Effective config (populated by _cfg_load)
REPO=""; WORK_TREE=""; HEALTHCHECK_URL=""; GIT_SIGNING_KEY=""; SYNC_INTERVAL=""
# Optional array override via env: SYNC_PATHS=(...)

# --- Minimal logger that mirrors to file (library handles journald) -----------
# We keep these lightweight; commands should use se_cmd, but for deterministic
# file logging and healthcheck POSTs we also mirror to LOG_FILE.
_log_ts(){ date +'%F %T'; }
_log(){ local lvl="$1"; shift; local msg="$*"; printf '[%s] %-5s %s\n' "$(_log_ts)" "$lvl" "$msg" | tee -a "$LOG_FILE" >&2; }
INFO(){ _log INFO "$@"; }
WARN(){ _log WARN "$@"; }
ERROR(){ _log ERROR "$@"; }
STEP(){ printf '\n[%s] ===== %s =====\n' "$(_log_ts)" "$*" | tee -a "$LOG_FILE" >&2; }

# --- Locking -----------------------------------------------------------------
_acquire_lock(){ exec {__LOCKFD}>"$LOCKFILE" || { ERROR "Cannot open lock $LOCKFILE"; return 1; }; flock -n "$__LOCKFD" || { WARN "Another git-sync is running; exiting"; return 2; }; }
_release_lock(){ [[ -n "${__LOCKFD:-}" ]] && eval "exec ${__LOCKFD}>&-" || true; }

# --- Helpers -----------------------------------------------------------------
require_root(){ [[ ${EUID:-$(id -u)} -eq 0 ]] || { ERROR "Must run as root"; return 64; }; }
_is_tty(){ [[ -t 0 && -t 1 ]]; }

_run(){ # run command, keep exit, mirror to LOG_FILE, show exact command via se_cmd
  local cmd="$*"; INFO "CMD $cmd"; set +e +o pipefail; bash -lc "$cmd" 2>&1 | tee -a "$LOG_FILE"; local rc=${PIPESTATUS[0]}; set -e -o pipefail; return "$rc";
}

# --- Config load/save (compat file; plus JSON metadata to XDG) ---------------
_cfg_load(){
  REPO="${PVE_GIT_REPO:-$DEFAULT_REPO}";
  WORK_TREE="$WORK_TREE_DEFAULT";
  HEALTHCHECK_URL="${HEALTHCHECKS_URL:-${DEFAULT_HEALTHCHECK_URL}}";
  SYNC_INTERVAL="${SYNC_INTERVAL:-$DEFAULT_TIMER_INTERVAL}";
  if [[ -f "$CONF_FILE" ]]; then
    # shellcheck disable=SC1090
    . "$CONF_FILE"
    [[ -z "${HEALTHCHECK_URL:-}" ]] && HEALTHCHECK_URL="$DEFAULT_HEALTHCHECK_URL"
    [[ -z "${SYNC_INTERVAL:-}"   ]] && SYNC_INTERVAL="$DEFAULT_TIMER_INTERVAL"
    [[ -z "${WORK_TREE:-}"       ]] && WORK_TREE="$WORK_TREE_DEFAULT"
  fi
  INFO "Using REPO='${REPO:-unset}' WORK_TREE='$WORK_TREE' INTERVAL='$SYNC_INTERVAL'"
}

_cfg_prompt_and_save(){
  _cfg_load
  if _is_tty && [[ ! -f "$CONF_FILE" ]]; then
    read -r -p "Repo SSH URL [${REPO:-none}]: " _in || true; REPO="${_in:-$REPO}"; _in=""
    read -r -p "Sync interval [${SYNC_INTERVAL}]: " _in || true; SYNC_INTERVAL="${_in:-$SYNC_INTERVAL}"; _in=""
    read -r -p "Working tree path [${WORK_TREE}]: " _in || true; WORK_TREE="${_in:-$WORK_TREE}"; _in=""
  fi
  umask 077
  cat >"$CONF_FILE" <<EOF
# git-sync configuration (legacy compat)
REPO="${REPO}"
WORK_TREE="${WORK_TREE}"
HEALTHCHECK_URL="${HEALTHCHECK_URL}"
GIT_SIGNING_KEY="${GIT_SIGNING_KEY}"
SYNC_INTERVAL="${SYNC_INTERVAL}"
# Example override for paths:
# SYNC_PATHS=(/etc/pve /etc/network)
# Size filters:
MAX_FILE_SIZE="${MAX_FILE_SIZE}"
SIZE_FILTER_BASE="${SIZE_FILTER_BASE}"
MAX_DIR_DEPTH="${MAX_DIR_DEPTH}"
MAX_DIR_SIZE_BYTES="${MAX_DIR_SIZE_BYTES}"
EOF
  chmod 0600 "$CONF_FILE"
  INFO "Saved configuration to $CONF_FILE"

  # Also persist JSON metadata to XDG (encrypted by default via library)
  local json; json=$(printf '{"installed_at":"%s","repo":"%s","work_tree":"%s","interval":"%s"}' "$(TZ=America/New_York date +'%F %T')" "$REPO" "$WORK_TREE" "$SYNC_INTERVAL")
  printf '%s\n' "$json" | se_config_write "$SLUG" || true
}

# --- Healthchecks (library + trimmed log POST) -------------------------------
_hc_limit(){
  local url="${HEALTHCHECK_URL%/}" n=""
  [[ -n "${HEALTHCHECK_LOG_BYTES:-}" ]] && { printf '%s\n' "$HEALTHCHECK_LOG_BYTES"; return; }
  n="$(curl -sI "$url" | awk -F': ' '/Ping-Body-Limit/{print $2}' | tr -d '\r')"
  [[ -n "$n" ]] && { printf '%s\n' "$n"; return; }
  printf '1000000\n'
}
_hc_post_file(){
  local base="$1" file="$2"; [[ -z "$base" ]] && return 0; [[ -f "$file" ]] || { WARN "Healthchecks log missing: $file"; return 0; }
  local tmp; tmp="$(mktemp /run/git-sync.hc.XXXX)" || return 0
  tail -c "$(_hc_limit)" "$file" >"$tmp" 2>/dev/null || true
  curl -sS -m 15 --retry 2 -H 'Content-Type: text/plain; charset=utf-8' --data-binary @"$tmp" -o /dev/null "$base" && rm -f "$tmp" || { rm -f "$tmp"; return 1; }
}
_hc_start(){ local hc; hc="$(se__hc_build_url "$SLUG")"; se_hc_start "$hc"; }
_hc_ok(){ local base="${HEALTHCHECK_URL%/}"; _hc_post_file "$base" "$LOG_FILE" || curl -sS -m 10 --retry 2 -o /dev/null "$base" || true; se_hc_success "$(se__hc_build_url "$SLUG")"; }
_hc_fail(){ local base="${HEALTHCHECK_URL%/}/fail"; _hc_post_file "$base" "$LOG_FILE" || curl -sS -m 10 --retry 2 -o /dev/null "$base" || true; se_hc_fail "$(se__hc_build_url "$SLUG")"; }

# --- Dependencies ------------------------------------------------------------
_ensure_deps(){
  STEP "Ensuring required packages"
  se_ensure_cmds git rsync openssh-client curl jq || return 69
  if ! command -v node >/dev/null || ! command -v npm >/dev/null; then
    INFO "Installing Node.js + npm via system package manager"
    if ! se_ensure_cmds nodejs npm; then WARN "Could not auto-install nodejs/npm"; fi
  fi
  if ! command -v aic >/dev/null && ! command -v aicommits >/dev/null; then
    INFO "Installing aicommits (npm i -g aicommits)"
    _run "npm install -g aicommits" || WARN "Failed to install aicommits; AI commit messages disabled"
    hash -r || true
  fi
}

_configure_aic_openai_key(){
  { command -v aicommits >/dev/null || command -v aic >/dev/null; } || return 0
  _is_tty || { INFO "No TTY; skipping OPENAI_KEY prompt"; return 0; }
  local have_key=""
  if command -v aicommits >/dev/null; then have_key="$(aicommits config list 2>/dev/null | grep -E '^OPENAI_KEY=')"; else have_key="$(aic config list 2>/dev/null | grep -E '^OPENAI_KEY=')"; fi
  [[ -n "$have_key" ]] && { INFO "aicommits OPENAI_KEY already configured"; return 0; }
  STEP "Configure aicommits OPENAI_KEY"
  printf 'Enter OPENAI API key for aicommits (leave blank to skip): '
  local _K; read -rs _K || true; printf '\n'
  if [[ -n "${_K:-}" ]]; then ( aicommits config set OPENAI_KEY="$_K" >/dev/null 2>&1 ) || WARN "Failed to set OPENAI_KEY"; INFO "aicommits OPENAI_KEY configured"; else WARN "No OPENAI_KEY provided; AI commit messages may not work"; fi
  unset _K
}

_install_gh_if_needed(){
  command -v gh >/dev/null && return 0
  STEP "Installing GitHub CLI (gh)"
  se_ensure_cmds gh || {
    # Fallback manual repo addition for Debian-like systems
    local arch codename keyring listfile; arch="$(dpkg --print-architecture 2>/dev/null || echo amd64)"; codename="$(. /etc/os-release 2>/dev/null; echo "${VERSION_CODENAME:-bookworm}")"; keyring="/usr/share/keyrings/githubcli-archive-keyring.gpg"; listfile="/etc/apt/sources.list.d/github-cli.list"
    se_ensure_cmds curl ca-certificates gnupg lsb-release || true
    _run "install -d -m 0755 /usr/share/keyrings"
    _run "curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg -o '$keyring'"
    _run "chmod 0644 '$keyring'"
    printf 'deb [arch=%s signed-by=%s] https://cli.github.com/packages stable main\n' "$arch" "$keyring" > "$listfile"
    _run "apt-get update -y" || true
    _run "apt-get install -y gh" || WARN "Failed to auto-install gh; key upload may need manual steps"
  }
}

# --- Git / SSH helpers -------------------------------------------------------
_ensure_github_known_host(){ _run "install -d -m 0700 /root/.ssh"; _run "touch /root/.ssh/known_hosts"; _run "chmod 0600 /root/.ssh/known_hosts"; ssh-keygen -F github.com >/dev/null 2>&1 || _run "ssh-keyscan -H github.com >> /root/.ssh/known_hosts"; }
_can_access_repo(){ local url="$1"; [[ -n "$url" ]] || return 1; GIT_SSH_COMMAND="ssh -o StrictHostKeyChecking=yes" git ls-remote "$url" &>/dev/null; }
_ensure_gh_auth_if_needed(){
  local repo_url="$1"; [[ -n "$repo_url" ]] || { ERROR "Repository URL empty"; return 64; }
  _ensure_github_known_host
  if _can_access_repo "$repo_url"; then INFO "SSH access to $repo_url ok; skipping GitHub auth"; return 0; fi
  STEP "SSH access not available; attempting gh auth + SSH key upload"
  _install_gh_if_needed
  if command -v gh >/dev/null; then
    gh auth status -h github.com >/dev/null 2>&1 || _run "gh auth login --git-protocol ssh" || true
    _run "gh config set -h github.com git_protocol ssh" || true
    _run "install -d -m 0700 /root/.ssh"
    [[ -f /root/.ssh/id_ed25519 ]] || _run "ssh-keygen -t ed25519 -C '$(whoami)@$(hostname)' -f /root/.ssh/id_ed25519 -N ''"
    _ensure_github_known_host
    _run "gh auth refresh -h github.com -s admin:public_key" || true
    [[ -f /root/.ssh/id_ed25519.pub ]] && _run "gh ssh-key add /root/.ssh/id_ed25519.pub --title 'host:$(hostname)'" || true
  else
    WARN "GitHub CLI unavailable; cannot auto-auth. Upload SSH pubkey manually if needed: /root/.ssh/id_ed25519.pub"
  fi
  _can_access_repo "$repo_url" || { ERROR "SSH access to $repo_url still failing"; return 69; }
}

_detect_default_branch(){ git -C "$WORK_TREE" symbolic-ref --quiet --short HEAD 2>/dev/null || git -C "$WORK_TREE" remote show origin 2>/dev/null | awk '/HEAD branch/ {print $NF}' || echo "main"; }

_seed_git_files(){
  if [[ ! -f "$WORK_TREE/.gitignore" ]]; then
    INFO "Seeding .gitignore"
    if [[ -d /data/coolify ]]; then cat >"$WORK_TREE/.gitignore" <<'EOF'
/data/coolify/db.sqlite
/data/coolify/db.sqlite-journal
/data/coolify/backups/
/data/coolify/tmp/
/data/coolify/volumes/
/data/coolify/node_modules/
/data/coolify/*.log
/data/coolify/*.tar
/data/coolify/*.gz
/data/coolify/*.zip
/data/coolify/*.img
/data/coolify/*.bin
/data/coolify/*.qcow2
/data/coolify/*.raw
*.log
*.tmp
*.bak
*.old
.DS_Store
Thumbs.db
.cache/
/root/.ssh/id_*
/root/.ssh/known_hosts.old
EOF
    elif [[ -d /etc/pve ]]; then cat >"$WORK_TREE/.gitignore" <<'EOF'
/var/lib/vz/images/
/var/lib/vz/snippets/
/var/lib/vz/template/iso/
/var/lib/vz/dump/
/var/lib/vz/backup/
*.qcow2
*.qcow
*.raw
*.img
*.vmdk
*.vdi
*.iso
*.ova
*.ovf
*.zst
*.xz
*.gz
*.bz2
*.tar
*.lzo
.cache/
pbs-cache/
pbs-chunks/
*.log
*.tmp
*.swp
*.swo
*.bak
*.old
.DS_Store
Thumbs.db
EOF
    fi
    ( cd "$WORK_TREE" && git add .gitignore && git commit -m "chore: seed environment-aware .gitignore" || true )
  fi
  if [[ ! -f "$WORK_TREE/.gitattributes" ]]; then
    INFO "Seeding .gitattributes"
    cat >"$WORK_TREE/.gitattributes" <<'EOF'
* text=auto eol=lf
*.conf diff
*.json diff
*.yaml diff
*.yml diff
*.service diff
*.timer diff
*.rules diff
EOF
    ( cd "$WORK_TREE" && git add .gitattributes && git commit -m "chore: add baseline .gitattributes" || true )
  fi
}

_seed_readme(){
  [[ -f "$WORK_TREE/README.md" ]] && return 0
  local ai_msg=""
  if command -v aicommits >/dev/null || command -v aic >/dev/null; then ai_msg="Detected aicommits — commit messages will be AI-generated."; else ai_msg="aicommits not detected. To enable AI commit messages: \`npm i -g aicommits\` and set \`OPENAI_KEY\`."; fi
  cat >"$WORK_TREE/README.md" <<EOF
# Config GitOps Snapshots

This repository stores text-based configuration snapshots produced by \`git-sync\`.

## Healthchecks
Default used by the script: \`${DEFAULT_HEALTHCHECK_URL}\`

## AI Commit Messages
${ai_msg}
EOF
  ( cd "$WORK_TREE" && git add README.md && git commit -m "docs: seed README with usage & AI commit notes" || true )
}

_bootstrap_repo_install(){
  _run "install -d -m 0755 '$WORK_TREE'"
  if [[ ! -d "$WORK_TREE/.git" ]]; then
    STEP "Cloning repository"
    _run "git clone --depth=1 '$REPO' '$WORK_TREE'" || { ERROR "git clone failed"; return 69; }
  else
    STEP "Updating repository"
    _run "git -C '$WORK_TREE' fetch --all --prune" || return 69
    _run "git -C '$WORK_TREE' pull --rebase --autostash" || return 69
  fi
  _seed_git_files; _seed_readme
  if [[ -n "${GIT_SIGNING_KEY:-}" ]]; then _run "git -C '$WORK_TREE' config user.signingkey '$GIT_SIGNING_KEY'"; _run "git -C '$WORK_TREE' config commit.gpgsign true"; fi
}

_bootstrap_repo_run(){
  _run "install -d -m 0755 '$WORK_TREE'"
  if [[ ! -d "$WORK_TREE/.git" ]]; then
    STEP "Cloning repository (no gh auth during run)"
    _run "git clone --depth=1 '$REPO' '$WORK_TREE'" || { ERROR "git clone failed (run mode). Ensure SSH access and run 'git-sync install' first."; return 69; }
  else
    STEP "Updating repository"
    if ! _run "git -C '$WORK_TREE' fetch --all --prune"; then WARN "git fetch failed (run); proceeding with local state"; else _run "git -C '$WORK_TREE' pull --rebase --autostash" || WARN "git pull failed (run); proceeding with local state"; fi
  fi
  _seed_git_files; _seed_readme
}

_ensure_git_identity(){
  local name email; name="$(git -C "$WORK_TREE" config --get user.name || true)"; email="$(git -C "$WORK_TREE" config --get user.email || true)";
  [[ -n "$name"  ]] || _run "git -C '$WORK_TREE' config user.name 'Host $(hostname)'"
  [[ -n "$email" ]] || _run "git -C '$WORK_TREE' config user.email 'root@$(hostname -f 2>/dev/null || hostname)'"
}

_commit_with_ai_or_fallback(){
  _ensure_git_identity
  local sign=""; [[ -n "${GIT_SIGNING_KEY:-}" ]] && sign="-S"
  local old new; old="$(git -C "$WORK_TREE" rev-parse HEAD 2>/dev/null || echo none)"
  if command -v aicommits >/dev/null; then
    INFO "Committing with aicommits --force"
    if _run "cd '$WORK_TREE' && echo | aicommits --force ${sign}"; then new="$(git -C "$WORK_TREE" rev-parse HEAD 2>/dev/null || echo none)"; if [[ "$old" != "$new" ]]; then INFO "AI commit (aicommits) $old -> $new"; return 0; else WARN "aicommits exited 0 but HEAD unchanged; falling back"; fi; else WARN "aicommits failed; falling back"; fi
  fi
  if command -v aic >/dev/null; then
    INFO "Committing with aic --force"
    if _run "cd '$WORK_TREE' && echo | aic --force ${sign}"; then new="$(git -C "$WORK_TREE" rev-parse HEAD 2>/dev/null || echo none)"; if [[ "$old" != "$new" ]]; then INFO "AI commit (aic) $old -> $new"; return 0; else WARN "aic exited 0 but HEAD unchanged; falling back"; fi; else WARN "aic failed; falling back"; fi
  fi
  local ts; ts="$(date +'%F %T %z')"; if _run "git -C '$WORK_TREE' commit ${sign} -m 'chore(git-sync): sync $(hostname) @ ${ts}'"; then new="$(git -C "$WORK_TREE" rev-parse HEAD 2>/dev/null || echo none)"; INFO "Fallback commit $old -> $new"; else ERROR "git commit failed"; _run "git -C '$WORK_TREE' status --porcelain=v1 || true"; _run "git -C '$WORK_TREE' log -1 --oneline || true"; return 70; fi
}

_hbytes(){ awk -v b="$1" 'BEGIN{split("B KiB MiB GiB TiB",u," ");s=1;while(b>=1024&&s<5){b/=1024;s++}printf("%.1f %s",b,u[s])}'; }
_build_coolify_dir_excludes(){
  local base="$SIZE_FILTER_BASE"; [[ -d "$base" ]] || return 0
  SIZE_EXCLUDE_FILE="$(mktemp /run/git-sync-excludes.XXXXXX)"; : >"$SIZE_EXCLUDE_FILE"
  STEP "Scanning '${base}' for oversize directories (> $(_hbytes "$MAX_DIR_SIZE_BYTES"), depth ≤ ${MAX_DIR_DEPTH})"
  while IFS=$'\t' read -r size path; do
    [[ "$path" == "$base" ]] && continue
    local rel="${path#$base}"; rel="${rel#/}"; [[ -z "$rel" ]] && continue
    local depth=$(( 1 + $(grep -o "/" <<<"$rel" | wc -l) ))
    if (( depth <= MAX_DIR_DEPTH )) && (( size > MAX_DIR_SIZE_BYTES )); then
      printf '/%s\n' "$rel" >> "$SIZE_EXCLUDE_FILE"; INFO "Excluding (dir) $(_hbytes "$size"): $path (depth $depth)"
    fi
  done < <(du -x -B1 --max-depth="$MAX_DIR_DEPTH" "$base" 2>/dev/null | sort -nr | tr '\t' ' ' | awk '{print $1"\t"$2}')
  INFO "Oversize directory patterns: $(wc -l < "$SIZE_EXCLUDE_FILE" | tr -d ' ')"
}

_perform_sync(){
  local hostdir="$WORK_TREE/host-$(hostname)"; _run "install -d -m 0755 '$hostdir'"
  local will_coolify=0; local p
  for p in "${SYNC_PATHS[@]:-${DEFAULT_SYNC_PATHS[@]}}"; do [[ "$p" == "$SIZE_FILTER_BASE" || "$p" == "$SIZE_FILTER_BASE/"* ]] && will_coolify=1; done
  if (( will_coolify==1 )) && [[ -d "$SIZE_FILTER_BASE" ]]; then _build_coolify_dir_excludes; fi
  STEP "Collecting config into $hostdir"
  local rs=( -a --delete --prune-empty-dirs --max-size="$MAX_FILE_SIZE" )
  local paths=( "${SYNC_PATHS[@]:-${DEFAULT_SYNC_PATHS[@]}}" )
  for p in "${paths[@]}"; do
    if [[ "$p" == *"*"* || "$p" == *"?"* || "$p" == *"["* ]]; then
      local parent rel_dir dest_dir; parent="$(dirname "$p")"; rel_dir="$(sed 's|^/||; s|/|-|g' <<<"$parent")"; dest_dir="$hostdir/$rel_dir"; _run "install -d -m 0755 '$dest_dir'"
      mapfile -t matches < <(compgen -G "$p" || true); if ((${#matches[@]}==0)); then WARN "Glob matched nothing: $p"; continue; fi
      local m; for m in "${matches[@]}"; do
        if [[ -f "$m" ]]; then _run "rsync ${rs[*]} '$m' '$dest_dir/$(basename "$m")'"; elif [[ -d "$m" ]]; then
          if [[ "$m" == "$SIZE_FILTER_BASE" || "$m" == "$SIZE_FILTER_BASE/"* ]] && [[ -n "${SIZE_EXCLUDE_FILE:-}" && -s "$SIZE_EXCLUDE_FILE" ]]; then
            _run "rsync ${rs[*]} --delete-excluded --exclude-from='$SIZE_EXCLUDE_FILE' '$m/' '$dest_dir/$(basename "$m")/'"
          else
            _run "rsync ${rs[*]} '$m/' '$dest_dir/$(basename "$m")/'"
          fi
        fi
      done
    else
      local rel dest; rel="$(sed 's|^/||; s|/|-|g' <<<"$p")"; dest="$hostdir/$rel"
      if [[ -d "$p" ]]; then
        if [[ "$p" == "$SIZE_FILTER_BASE" || "$p" == "$SIZE_FILTER_BASE/"* ]] && [[ -n "${SIZE_EXCLUDE_FILE:-}" && -s "$SIZE_EXCLUDE_FILE" ]]; then _run "rsync ${rs[*]} --delete-excluded --exclude-from='$SIZE_EXCLUDE_FILE' '$p/' '$dest/'"; else _run "rsync ${rs[*]} '$p/' '$dest/'"; fi
      elif [[ -f "$p" ]]; then _run "install -d -m 0755 '$(dirname "$dest")'"; _run "rsync ${rs[*]} '$p' '$dest'"; else WARN "Skipping missing path: $p"; fi
    fi
  done
  [[ -n "${SIZE_EXCLUDE_FILE:-}" && -f "$SIZE_EXCLUDE_FILE" ]] && rm -f "$SIZE_EXCLUDE_FILE" || true
  STEP "Staging & committing"; _run "git -C '$WORK_TREE' add -A"; if ! git -C "$WORK_TREE" diff --cached --quiet; then _commit_with_ai_or_fallback; else INFO "No changes detected; nothing to commit"; fi
  STEP "Pushing"
  if _can_access_repo "$REPO"; then local branch; branch="$(_detect_default_branch)"; _run "git -C '$WORK_TREE' push origin 'HEAD:${branch}'" && INFO "Pushed to ${branch}" || WARN "Push failed"; else WARN "Remote unreachable; leaving commits local"; fi
}

# --- systemd units -----------------------------------------------------------
_install_units(){
  STEP "Installing systemd service & timer"
  cat >"$SERVICE_PATH" <<EOF
[Unit]
Description=Proxmox/Coolify config Git sync
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
ExecStart=${0} run
User=root
Group=root
EnvironmentFile=-${CONF_FILE}
Nice=10
IOSchedulingClass=best-effort
IOSchedulingPriority=7

[Install]
WantedBy=multi-user.target
EOF
  cat >"$TIMER_PATH" <<EOF
[Unit]
Description=Run git-sync periodically

[Timer]
OnBootSec=5m
OnUnitActiveSec=${SYNC_INTERVAL}
AccuracySec=1m
RandomizedDelaySec=2m
Unit=${SERVICE_NAME}
Persistent=true

[Install]
WantedBy=timers.target
EOF
  _run "systemctl daemon-reload"; _run "systemctl enable --now '$TIMER_NAME'"; INFO "Enabled timer ${TIMER_NAME} (interval: ${SYNC_INTERVAL})"
}

_uninstall_units(){ STEP "Removing systemd service & timer"; _run "systemctl disable --now '$TIMER_NAME'" || true; _run "systemctl disable --now '$SERVICE_NAME'" || true; rm -f "$TIMER_PATH" "$SERVICE_PATH"; _run "systemctl daemon-reload"; INFO "Removed service and timer"; }

_show_status(){ STEP "Service status"; _run "systemctl status '$SERVICE_NAME' --no-pager" || true; printf '\n---- Recent logs (last hour) ----\n' | tee -a "$LOG_FILE"; _run "journalctl -u '$SERVICE_NAME' --since '1h' --no-pager" || true; printf '\n---- Timer status ----\n' | tee -a "$LOG_FILE"; _run "systemctl list-timers --all | grep -E '$TIMER_NAME|NEXT|UNIT' -n --color=never" || true; }

# --- Steps -------------------------------------------------------------------
step_10_preflight(){ require_root || return 64; _acquire_lock || return 0; : >"$LOG_FILE" 2>/dev/null || true; INFO "git-sync starting (pid=$$)"; }
step_20_config(){ if [[ "${MODE:-run}" == install ]]; then _cfg_prompt_and_save; else _cfg_load; fi; }
step_30_hc_start(){ _hc_start; }
step_40_deps(){ _ensure_deps || return 69; [[ "${MODE:-run}" == install ]] && _configure_aic_openai_key || true; }
step_50_auth_install(){ [[ "${MODE:-run}" == install ]] || return 0; _ensure_github_known_host; _ensure_gh_auth_if_needed "$REPO"; }
step_60_repo(){ if [[ "${MODE:-run}" == install ]]; then _bootstrap_repo_install; else _bootstrap_repo_run; fi }
step_70_sync(){ _perform_sync; }
step_80_units(){ [[ "${MODE:-run}" == install ]] || return 0; _install_units; }

# --- Main orchestration ------------------------------------------------------
_main(){
  local hc; hc="$(se__hc_build_url "$SLUG")"
  se_ndjson_init "$SLUG"
  if ! se_run_steps step_10_preflight step_20_config step_30_hc_start step_40_deps step_50_auth_install step_60_repo step_70_sync step_80_units; then
    local rc=$?; se_ndjson_finalize "$VERSION" "$rc" "${START_FROM:-}" "step-failed" "fail"; _hc_fail; _release_lock; return "$rc"
  fi
  se_ndjson_finalize "$VERSION" 0 "${START_FROM:-}" "" "ok"; _hc_ok; _release_lock; return 0
}

# --- CLI ---------------------------------------------------------------------
_usage(){ cat <<'USAGE'
Usage: git-sync [install|run|status|uninstall|self-update|recover|help|debug]

Subcommands
  install       Initialize & overwrite config/state; set up systemd timer
  run           Perform a one-off sync now (default action)
  status        Show systemd status and recent logs
  uninstall     Remove installed service + timer
  self-update   Fetch, validate, stage, and atomically link latest script
  recover       Interactive recovery shell (vim; auto-exits after inactivity)
  help          Show this help, env vars table, examples, key paths
  debug         Run with verbose logging; confirm each command when configured

Environment Variables (selected)
  PVE_GIT_REPO, WORK_TREE, HEALTHCHECKS_URL, HEALTHCHECK_LOG_BYTES,
  GIT_SIGNING_KEY, SYNC_INTERVAL, PVE_GIT_DEBUG, SYNC_PATHS[],
  MAX_FILE_SIZE, SIZE_FILTER_BASE, MAX_DIR_DEPTH, MAX_DIR_SIZE_BYTES

Examples
  PVE_GIT_REPO=git@github.com:me/proxmox-configs.git git-sync install
  SYNC_INTERVAL=5m git-sync install
  SYNC_PATHS=(/etc/pve /etc/network) git-sync run
USAGE
}

case "${1:-run}" in
  install)     MODE=install _main ;;
  run|"")    MODE=run _main ;;
  status)      _cfg_load; _hc_start; _show_status; _hc_ok ;;
  uninstall)   _cfg_load; _hc_start; _uninstall_units; _hc_ok ;;
  self-update) se_self_update "$SLUG" "$UPDATE_URL" "/usr/local/bin/$SLUG" ;;
  recover)     se_recover_shell "$SLUG" ;;
  help)        _usage ;;
  debug)       DEBUG=1 CONFIRM_COMMAND=${CONFIRM_COMMAND:-1} MODE=run _main ;;
  *)           _usage; exit 64 ;;
esac

exit $?
